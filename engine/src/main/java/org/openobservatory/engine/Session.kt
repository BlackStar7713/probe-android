package org.openobservatory.engine

import oonimkall.*

/** OONIContext is the context for long running tasks.  */
class OONIContext internal constructor(var ctx: Context) {
    fun cancel() {
        ctx.cancel()
    }
}

/** OONISessionConfig contains configuration for a OONISession.  */
class OONISessionConfig {
    /**
     * assetsDir is a mandatory setting specifying the directory in
     * which you want the OONI Probe engine to store the assets.
     */
    @JvmField
    var assetsDir: String? = null

    /**
     * logger is an optional setting specifying a logger where
     * to send log messages generated by OONI Probe's engine.
     */
    @JvmField
    var logger: OONILogger? = null

    /**
     * ProbeServicesURL allows you to optionally force the
     * usage of an alternative probe services. This setting
     * should only be used to implement integration tests.
     */
    var probeServicesURL: String? = null

    /**
     * softwareName is a mandatory setting specifying the name of
     * the application that is using OONI Probe's engine.
     */
    @JvmField
    var softwareName: String? = null

    /**
     * softwareVersion is a mandatory setting specifying the version of
     * the application that is using OONI Probe's engine.
     */
    @JvmField
    var softwareVersion: String? = null

    /**
     * stateDir is a mandatory setting specifying the directory in
     * which you want the OONI Probe engine to store its state.
     */
    @JvmField
    var stateDir: String? = null

    /**
     * tempDir is a mandatory setting specifying the directory in which
     * you want the OONI Probe engine to store temporary files.
     */
    @JvmField
    var tempDir: String? = null

    /**
     * verbose controls whether to emit debug messages. This setting only
     * has effect if you also specify a Logger using setLogger.
     */
    @JvmField
    var verbose = false

    fun toOonimkallSessionConfig(): SessionConfig {
        val c = SessionConfig()
        c.assetsDir = assetsDir
        c.logger = PELoggerAdapter(logger!!)
        c.probeServicesURL = probeServicesURL
        c.softwareName = softwareName
        c.softwareVersion = softwareVersion
        c.stateDir = stateDir
        c.tempDir = tempDir
        c.verbose = verbose
        return c
    }
}

/**
 * OONISession contains shared state for running experiments and/or other
 * related task (e.g. geolocation). Note that a OONISession is not meant to
 * be a long running instance. The expected usage is that you create a new
 * session, use it immediately, and then forget about it.
 */
interface OONISession {
    /** geolocate returns the probe geolocation.  */
    @Throws(OONIException::class)
    fun geolocate(ctx: OONIContext): OONIGeolocateResults

    /** maybeUpdateResources updates resources if needed.  */
    @Throws(OONIException::class)
    fun maybeUpdateResources(ctx: OONIContext)

    /** newContext creates a new OONIContext instance.  */
    fun newContext(): OONIContext

    /**
     * newContextWithTimeout creates a new OONIContext instance that times
     * out after the specified number of seconds. A zero or negative timeout
     * is equivalent to create a OONIContext without a timeout.
     */
    fun newContextWithTimeout(timeout: Long): OONIContext

    /** submit submits a measurement and returns the submission results.  */
    @Throws(OONIException::class)
    fun submit(ctx: OONIContext, measurement: String): OONISubmitResults
}

/** OONIGeolocateResults contains the results of OONIGeolocateTask.  */
class OONIGeolocateResults(r: GeolocateResults) {
    /** ASN is the probe ASN.  */
    val ASN: String

    /** country is the probe country.  */
    @JvmField
    val country: String

    /** IP is the probe IP.  */
    val IP: String

    /** org is the probe ASN organization.  */
    val org: String

    init {
        ASN = r.asn
        country = r.country
        IP = r.ip
        org = r.org
    }
}

/**
 * OONISubmitResults contains the results of a single measurement submission
 * to the OONI backends using the OONI collector API.
 */
class OONISubmitResults(r: SubmitMeasurementResults) {
    /** updatedMeasurement is a copy of the original measurement
     * in which the report ID has been updated.  */
    @JvmField
    val updatedMeasurement: String

    /** updatedReportID returns the updated report ID.  */
    @JvmField
    val updatedReportID: String

    init {
        updatedMeasurement = r.updatedMeasurement
        updatedReportID = r.updatedReportID
    }
}

internal class PESession(config: OONISessionConfig) : OONISession {
    private var session: Session? = null

    @Throws(OONIException::class)
    override fun geolocate(ctx: OONIContext): OONIGeolocateResults {
        return try {
            OONIGeolocateResults(session!!.geolocate(ctx.ctx))
        } catch (exc: Exception) {
            throw OONIException("session.geolocate failed", exc)
        }
    }

    @Throws(OONIException::class)
    override fun maybeUpdateResources(ctx: OONIContext) {
        try {
            session!!.maybeUpdateResources(ctx.ctx)
        } catch (exc: Exception) {
            throw OONIException("session.maybeUpdateResources failed", exc)
        }
    }

    override fun newContext(): OONIContext {
        return newContextWithTimeout(-1)
    }

    override fun newContextWithTimeout(timeout: Long): OONIContext {
        return OONIContext(session!!.newContextWithTimeout(timeout))
    }

    @Throws(OONIException::class)
    override fun submit(ctx: OONIContext, measurement: String): OONISubmitResults {
        return try {
            OONISubmitResults(session!!.submit(ctx.ctx, measurement))
        } catch (exc: Exception) {
            throw OONIException("", exc)
        }
    }

    init {
        session = try {
            Oonimkall.newSession(config.toOonimkallSessionConfig())
        } catch (exc: Exception) {
            throw OONIException("Oonimkall.newSession failed", exc)
        }
    }
}
